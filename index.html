<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Appointment Planner (3 Weeks)</title>
  <style>
    :root {
      --bg: #fafafa;
      --card: #ffffff;
      --border: #e4e4e7;
      --text: #18181b;
      --muted: #71717a;
      --primary: #18181b;
      --accent: #059669;
      --danger: #dc2626;
      --warning: #b45309;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      background: var(--card);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    h1 { margin: 0 0 4px 0; font-size: 22px; }
    header p { margin: 0; font-size: 13px; color: var(--muted); }

    main { padding: 16px; max-width: 1200px; margin: 0 auto; }

    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }

    button {
      border: 1px solid var(--border);
      background: var(--card);
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }
    button.primary { background: var(--primary); color: white; border-color: #111; }
    button.confirm { background: var(--accent); color: white; border-color: #047857; }
    button.danger { background: var(--danger); color: white; border-color: #b91c1c; }
    button.ghost { background: transparent; }
    button.small { padding: 4px 8px; font-size: 12px; border-radius: 9px; }
    button:hover { opacity: 0.92; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    input, select {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 14px;
      background: white;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .scroll-x { overflow-x: auto; }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 980px;
    }

    th, td {
      border: 1px solid var(--border);
      padding: 10px;
      vertical-align: top;
    }

    th {
      background: #f4f4f5;
      text-align: left;
      font-size: 13px;
    }

    .dayCell {
      width: 220px;
      background: #fafafa;
      font-weight: 600;
      position: sticky;
      left: 0;
      z-index: 2;
    }

    tr.weekBreak td, tr.weekBreak th {
      border-top: 3px solid #cbd5e1;
    }

    .weekLabel {
      display: inline-flex;
      gap: 8px;
      align-items: baseline;
    }

    .weekPill {
      font-size: 11px;
      color: white;
      background: #334155;
      border-radius: 999px;
      padding: 2px 8px;
      font-weight: 700;
    }

    .status {
      font-size: 11px;
      padding: 2px 7px;
      border-radius: 999px;
      display: inline-block;
      margin-left: 6px;
      font-weight: 600;
    }
    .proposed { background: #dbeafe; color: #1e40af; }
    .confirmed { background: #d1fae5; color: #065f46; }
    .removed { background: #f4f4f5; color: #71717a; }

    .option {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px;
      margin-bottom: 8px;
      font-size: 13px;
      background: white;
    }

    .optionActions { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }

    .hint { font-size: 12px; color: var(--muted); }

    /* Modal */
    .modalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 50;
    }
    .modal {
      width: 100%;
      max-width: 760px;
      background: white;
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.22);
      overflow: hidden;
    }
    .modalHeader {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      background: #fcfcfd;
    }
    .modalHeader h2 { margin: 0; font-size: 16px; }
    .modalBody { padding: 14px; }

    .gridDays {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
    }

    .gridTimes {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .slotBtn {
      width: 100%;
      text-align: center;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: white;
      font-weight: 600;
    }
    .slotBtn.selected {
      background: #111827;
      color: white;
      border-color: #111827;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 10px;
      background: white;
      font-size: 12px;
      margin-right: 6px;
      margin-bottom: 6px;
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 12px 0;
    }

    .subtle {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 14px;
      padding: 12px;
    }

    .conflict {
      font-size: 12px;
      color: var(--warning);
      font-weight: 600;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Appointment Planner</h1>
    <p>Offer multiple time options per contact, confirm one, and keep a clean 3‑week overview (Mon–Fri, <span id="windowSummary">09:00–14:00</span>).</p>
    <div class="row tabs" style="margin-top:10px;">
      <button class="active" id="tab_calendar" onclick="setView('calendar')">Calendar</button>
      <button id="tab_availability" onclick="setView('availability')">Available slots</button>
      <button id="tab_confirmed" onclick="setView('confirmed')">Confirmed</button>
      <button class="primary" onclick="addContact()">+ Add contact</button>
      <button class="ghost" onclick="resetAll()" title="Clears data from this browser">Reset</button>
    </div>
    <div class="row" style="margin-top:10px;">
      <label class="row" style="gap:6px; align-items:center;">
        <span class="hint">Appointment window:</span>
        <input type="time" id="windowStart" step="1800" value="09:00" />
      </label>
      <span class="hint">to</span>
      <label class="row" style="gap:6px; align-items:center;">
        <input type="time" id="windowEnd" step="1800" value="14:00" />
      </label>
      <button class="small" onclick="applyWindowSettings()">Update window</button>
    </div>
  </header>

  <main>
    <div id="app"></div>
  </main>

  <!-- Slot Picker Modal -->
  <div class="modalOverlay" id="slotModalOverlay" onclick="onModalOverlayClick(event)">
    <div class="modal" onclick="event.stopPropagation()">
      <div class="modalHeader">
        <div>
          <h2 id="slotModalTitle">Pick options</h2>
          <div class="hint" id="slotModalSubtitle">Choose a weekday, then select 30‑minute slots from 09:00–14:00.</div>
        </div>
        <div class="row">
          <button class="small" onclick="closeSlotModal()">✕</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="subtle">
          <div class="row" style="justify-content: space-between;">
            <div style="font-weight:700;">Step 1: pick a day</div>
            <div class="hint">Only weekdays (Mon–Fri) are shown.</div>
          </div>
          <div class="divider"></div>
          <div id="dayPicker"></div>
        </div>

        <div class="divider"></div>

        <div class="subtle" id="timeStep" style="display:none;">
          <div class="row" style="justify-content: space-between;">
            <div style="font-weight:700;">Step 2: pick times</div>
            <div class="hint" id="pickedDayLabel"></div>
          </div>
          <div class="divider"></div>
          <div id="timePicker"></div>
          <div class="divider"></div>
          <div>
            <div class="hint" style="margin-bottom:6px;">Selected:</div>
            <div id="selectedChips"></div>
            <label class="row" style="margin-top:10px; gap:6px; align-items:center;">
              <input type="checkbox" id="slotModalConfirmToggle" />
              <span class="hint">Add these as confirmed appointments (archives other proposed options for this contact).</span>
            </label>
            <div class="row" style="justify-content: flex-end; margin-top: 10px;">
              <button onclick="clearSelections()">Clear</button>
              <button class="primary" id="saveSelectionsBtn" onclick="saveSelections()">Add options</button>
            </div>
          </div>
        </div>

        <div class="subtle" id="slotModalSuggested" style="margin-top:12px; display:none;"></div>

        <div class="hint" style="margin-top:10px;">Tip: You can open this picker anytime from the contact column header.</div>
      </div>
    </div>
  </div>

  <!-- Assign Modal (Availability → Add to contact) -->
  <div class="modalOverlay" id="assignModalOverlay" onclick="onAssignOverlayClick(event)">
    <div class="modal" onclick="event.stopPropagation()" style="max-width:520px;">
      <div class="modalHeader">
        <div>
          <h2>Add this slot as an option</h2>
          <div class="hint" id="assignSlotLabel"></div>
        </div>
        <button class="small" onclick="closeAssignModal()">✕</button>
      </div>
      <div class="modalBody">
        <div class="row" style="gap:10px; align-items:flex-end;">
          <label style="display:grid; gap:6px; flex: 1;">
            <span class="hint">Choose contact</span>
            <select id="assignContactSelect"></select>
          </label>
          <button class="primary" onclick="confirmAssignSlot()">Add option</button>
        </div>
        <label class="row" style="margin-top:12px; gap:6px; align-items:center;">
          <input type="checkbox" id="assignConfirmToggle" />
          <span class="hint">Mark as confirmed (archives other proposed options for this contact).</span>
        </label>
      </div>
    </div>
  </div>

<script>
  const STORAGE_KEY = "appt_planner_html_v2";

  // Standard slots: Mon–Fri through the end of the third week, 30-min blocks from a configurable window
  const DEFAULT_WINDOW = { startTime: "09:00", endTime: "14:00" };
  const SLOT_MINUTES = 30;
  const PLANNER_WEEKS = 3;
  let view = "calendar";

  let state = safeLoad() || { contacts: [], settings: { ...DEFAULT_WINDOW } };

  // Modal state
  let slotModal = {
    open: false,
    contactId: null,
    chosenDay: null, // Date at start of day
    selected: [], // [{startISO,endISO}]
    markConfirmed: false,
  };

  let assignModal = {
    open: false,
    slot: null, // {startISO,endISO}
  };

  function safeLoad() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.contacts)) return null;
      // Basic normalization
      parsed.contacts.forEach(c => {
        c.options = Array.isArray(c.options) ? c.options : [];
        c.archivedOptions = Array.isArray(c.archivedOptions) ? c.archivedOptions : [];
        const activeOptions = [];
        c.options.forEach(o => {
          if (!o.status) o.status = 'proposed';
          if (o.status === 'removed') {
            c.archivedOptions.push({ ...o, status: 'removed' });
          } else {
            activeOptions.push(o);
          }
        });
        c.options = activeOptions;
      });
      parsed.settings = normalizeSettings(parsed.settings);
      return parsed;
    } catch {
      return null;
    }
  }

  function save() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  function normalizeSettings(settings) {
    const safe = { ...DEFAULT_WINDOW, ...(settings || {}) };
    const start = parseTimeToMinutes(safe.startTime);
    const end = parseTimeToMinutes(safe.endTime);
    if (Number.isNaN(start) || Number.isNaN(end) || start >= end) {
      return { ...DEFAULT_WINDOW };
    }
    return safe;
  }

  function parseTimeToMinutes(value) {
    if (!value || typeof value !== "string") return NaN;
    const [h, m] = value.split(":").map(Number);
    if (Number.isNaN(h) || Number.isNaN(m)) return NaN;
    return h * 60 + m;
  }

  function minutesToTime(minutes) {
    const h = String(Math.floor(minutes / 60)).padStart(2, "0");
    const m = String(minutes % 60).padStart(2, "0");
    return `${h}:${m}`;
  }

  function getWindowConfig() {
    const settings = normalizeSettings(state.settings);
    const startMinutes = parseTimeToMinutes(settings.startTime);
    const endMinutes = parseTimeToMinutes(settings.endTime);
    return {
      startMinutes,
      endMinutes,
      startLabel: settings.startTime,
      endLabel: settings.endTime,
    };
  }

  function applyWindowSettings() {
    const startInput = document.getElementById("windowStart");
    const endInput = document.getElementById("windowEnd");
    const startTime = startInput.value;
    const endTime = endInput.value;
    const startMinutes = parseTimeToMinutes(startTime);
    const endMinutes = parseTimeToMinutes(endTime);
    if (Number.isNaN(startMinutes) || Number.isNaN(endMinutes) || startMinutes >= endMinutes) {
      alert("Please pick a valid window where the start time is before the end time.");
      syncWindowInputs();
      return;
    }
    state.settings = { startTime, endTime };
    save();
    updateWindowLabels();
    render();
  }

  function updateWindowLabels() {
    const { startLabel, endLabel } = getWindowConfig();
    const summary = `${startLabel}–${endLabel}`;
    const summaryEl = document.getElementById("windowSummary");
    if (summaryEl) summaryEl.textContent = summary;
    const subtitle = document.getElementById("slotModalSubtitle");
    if (subtitle) subtitle.textContent = `Choose a weekday, then select ${SLOT_MINUTES}-minute slots from ${summary}.`;
  }

  function syncWindowInputs() {
    const { startLabel, endLabel } = getWindowConfig();
    const startInput = document.getElementById("windowStart");
    const endInput = document.getElementById("windowEnd");
    if (startInput) startInput.value = startLabel;
    if (endInput) endInput.value = endLabel;
  }

  function resetAll() {
    if (!confirm("Reset all data in this browser?")) return;
    localStorage.removeItem(STORAGE_KEY);
    state = { contacts: [], settings: { ...DEFAULT_WINDOW } };
    syncWindowInputs();
    updateWindowLabels();
    render();
  }

  function setView(v) {
    view = v;
    document.getElementById('tab_calendar').classList.toggle('active', v === 'calendar');
    document.getElementById('tab_availability').classList.toggle('active', v === 'availability');
    document.getElementById('tab_confirmed').classList.toggle('active', v === 'confirmed');
    render();
  }

  function addContact() {
    const name = prompt("Contact name:");
    if (!name) return;
    const email = prompt("Email (optional):") || "";
    const contact = { id: crypto.randomUUID(), name: name.trim(), email: email.trim(), options: [], archivedOptions: [] };
    state.contacts.push(contact);
    const wantsAutoPick = confirm("Auto-pick 3 suggested options? (Next weekday, then every other day)");
    if (wantsAutoPick) {
      const suggestedSlots = getAutoSuggestedSlots(contact.id, 3);
      if (suggestedSlots.length === 0) {
        alert("No free slots available for the suggested days. Please pick manually.");
      }
      openSlotModal(contact.id, suggestedSlots);
    } else {
      // Pop up slot picker right after adding
      openSlotModal(contact.id);
    }
    save();
    render();
  }

  function deleteContact(cid) {
    const c = state.contacts.find(x => x.id === cid);
    if (!c) return;
    if (!confirm(`Delete contact “${c.name}”? This removes all their options.`)) return;
    state.contacts = state.contacts.filter(x => x.id !== cid);
    save(); render();
  }

  function confirmOption(cid, oid, { silent = false } = {}) {
    const c = state.contacts.find(x => x.id === cid);
    if (!c) return;
    const archived = [];
    c.options = c.options.filter(o => {
      if (o.id === oid) {
        o.status = "confirmed";
        return true;
      }
      if (o.status === "proposed") {
        archived.push({ ...o, status: "removed", archivedAt: new Date().toISOString() });
        return false;
      }
      return true;
    });
    c.archivedOptions.push(...archived);
    if (!silent) {
      save();
      render();
    }
  }

  function archiveOption(cid, oid) {
    const c = state.contacts.find(x => x.id === cid);
    if (!c) return;
    const idx = c.options.findIndex(o => o.id === oid);
    if (idx === -1) return;
    const [removed] = c.options.splice(idx, 1);
    c.archivedOptions.push({ ...removed, status: 'removed', archivedAt: new Date().toISOString() });
    save(); render();
  }

  function restoreArchivedOption(cid, oid) {
    const c = state.contacts.find(x => x.id === cid);
    if (!c) return;
    const idx = c.archivedOptions.findIndex(o => o.id === oid);
    if (idx === -1) return;
    const [restored] = c.archivedOptions.splice(idx, 1);
    c.options.push({ ...restored, status: 'proposed' });
    save(); render();
  }

  function deleteArchivedOption(cid, oid) {
    const c = state.contacts.find(x => x.id === cid);
    if (!c) return;
    c.archivedOptions = c.archivedOptions.filter(o => o.id !== oid);
    save(); render();
  }

  function toStartOfDay(d) {
    const x = new Date(d);
    x.setHours(0,0,0,0);
    return x;
  }

  function addDays(d, n) {
    const x = new Date(d);
    x.setDate(x.getDate() + n);
    return x;
  }

  function startOfWeekMonday(d) {
    const day = toStartOfDay(d);
    const diff = (day.getDay() + 6) % 7;
    return addDays(day, -diff);
  }

  function isWeekday(d) {
    const wd = d.getDay();
    return wd >= 1 && wd <= 5;
  }

  function fmtDay(d) {
    return d.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: '2-digit' });
  }

  function fmtTime(d) {
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function formatSlotLabel(slot, locale) {
    const date = new Date(slot.startISO);
    const dateLabel = date.toLocaleDateString(locale, { weekday: 'short', month: 'short', day: '2-digit' });
    const timeLabel = date.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' });
    return `${dateLabel} ${timeLabel}`;
  }

  function formatGermanSlotLabel(slot) {
    const date = new Date(slot.startISO);
    const weekday = date.toLocaleDateString('de-DE', { weekday: 'long' });
    const timeLabel = date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
    return `${weekday} um ${timeLabel}`;
  }

  function joinWithOr(items, locale) {
    if (items.length === 0) return '';
    if (items.length === 1) return items[0];
    if (items.length === 2) return `${items[0]} ${locale === 'de-DE' ? 'oder' : 'or'} ${items[1]}`;
    return `${items.slice(0, -1).join(', ')} ${locale === 'de-DE' ? 'oder' : 'or'} ${items[items.length - 1]}`;
  }

  function buildAvailabilityMessages(options) {
    const { startLabel, endLabel } = getWindowConfig();
    const slots = options
      .slice()
      .sort((a, b) => new Date(a.startISO) - new Date(b.startISO))
      .slice(0, 3);

    const enSlots = slots.map(slot => formatSlotLabel(slot, 'en-US'));
    const deSlots = slots.map(slot => formatGermanSlotLabel(slot));

    const english = `Do you happen to have time at ${joinWithOr(enSlots, 'en-US')}? If you do not, please suggest 2 dates between ${startLabel} and ${endLabel}.`;
    const german = `Hättest du zufällig am ${joinWithOr(deSlots, 'de-DE')} Uhr Zeit? Falls nicht, schlagen Sie bitte 2 Termine zwischen ${startLabel} und ${endLabel} vor.`;

    return { english, german };
  }

  function overlaps(aStart, aEnd, bStart, bEnd) {
    return aStart < bEnd && bStart < aEnd;
  }

  function getActiveRanges() {
    const ranges = [];
    state.contacts.forEach(c => {
      c.options.forEach(o => {
        if (o.status === 'confirmed' || o.status === 'proposed') {
          ranges.push({
            start: new Date(o.startISO),
            end: new Date(o.endISO),
            contactId: c.id,
            optionId: o.id,
            status: o.status,
          });
        }
      });
    });
    return ranges;
  }

  function getPlannerDays() {
    const today = toStartOfDay(new Date());
    const weekStart = startOfWeekMonday(today);
    const endOfThirdWeek = addDays(weekStart, PLANNER_WEEKS * 7 - 1);
    const daysCount = Math.floor((endOfThirdWeek - today) / (24 * 60 * 60 * 1000)) + 1;
    return Array.from({ length: daysCount }, (_, i) => addDays(today, i));
  }

  function getWeekSegments() {
    const days = getPlannerDays();
    const weeks = [];
    let current = [];
    days.forEach((day, idx) => {
      if (idx !== 0 && day.getDay() === 1) {
        weeks.push(current);
        current = [];
      }
      current.push(day);
    });
    if (current.length) weeks.push(current);
    return weeks;
  }

  function getWeekIndex(day) {
    const target = toStartOfDay(day).toISOString();
    const weeks = getWeekSegments();
    for (let i = 0; i < weeks.length; i++) {
      const found = weeks[i].some(d => toStartOfDay(d).toISOString() === target);
      if (found) return i + 1;
    }
    return 1;
  }

  function getStandardSlots() {
    const days = getPlannerDays().filter(isWeekday);
    const slots = [];
    const { startMinutes, endMinutes } = getWindowConfig();
    for (const day of days) {
      for (let minutes = startMinutes; minutes < endMinutes; minutes += SLOT_MINUTES) {
        const start = new Date(day);
        start.setHours(Math.floor(minutes / 60), minutes % 60, 0, 0);
        const end = new Date(start.getTime() + SLOT_MINUTES * 60000);
        const endMinutesValue = end.getHours() * 60 + end.getMinutes();
        if (endMinutesValue > endMinutes) continue;
        slots.push({ startISO: start.toISOString(), endISO: end.toISOString() });
      }
    }
    return slots;
  }

  function isSameDay(a, b) {
    return toStartOfDay(a).getTime() === toStartOfDay(b).getTime();
  }

  function getAutoPickDays(count) {
    const today = toStartOfDay(new Date());
    const plannerEnd = addDays(startOfWeekMonday(today), PLANNER_WEEKS * 7 - 1);
    const days = [];
    let cursor = addDays(today, 1);
    let lastPicked = null;
    const minGapMs = 2 * 24 * 60 * 60 * 1000;

    while (days.length < count && cursor <= plannerEnd) {
      if (isWeekday(cursor)) {
        if (!lastPicked || (toStartOfDay(cursor) - toStartOfDay(lastPicked)) >= minGapMs) {
          days.push(new Date(cursor));
          lastPicked = cursor;
        }
      }
      cursor = addDays(cursor, 1);
    }

    return days;
  }

  function getFreeSlotsForDay(day) {
    const blocked = getActiveRanges();
    return getStandardSlots().filter(s => {
      const start = new Date(s.startISO);
      if (!isSameDay(start, day)) return false;
      const end = new Date(s.endISO);
      return !blocked.some(r => overlaps(start, end, r.start, r.end));
    });
  }

  function pickSlotForDay(day, preference) {
    const slots = getFreeSlotsForDay(day)
      .slice()
      .sort((a, b) => new Date(a.startISO) - new Date(b.startISO));
    if (!slots.length) return null;

    if (preference === 'early') return slots[0];
    if (preference === 'late') return slots[slots.length - 1];
    const midIndex = Math.floor(slots.length / 2);
    return slots[midIndex];
  }

  function getAutoSuggestedSlots(contactId, count) {
    const contact = state.contacts.find(x => x.id === contactId);
    if (!contact) return [];

    const preferences = ['late', 'early', 'middle'];
    const days = getAutoPickDays(count);
    const existingStarts = new Set(contact.options.map(o => o.startISO));
    const selectedSlots = [];

    days.forEach((day, index) => {
      const pref = preferences[index] || 'middle';
      const slot = pickSlotForDay(day, pref);
      if (!slot || existingStarts.has(slot.startISO)) return;
      selectedSlots.push({ startISO: slot.startISO, endISO: slot.endISO });
      existingStarts.add(slot.startISO);
    });

    return selectedSlots;
  }

  // --- Slot Picker Modal ---
  function openSlotModal(contactId, preselectedSlots = []) {
    slotModal.open = true;
    slotModal.contactId = contactId;
    slotModal.chosenDay = null;
    slotModal.selected = preselectedSlots.map(slot => ({
      startISO: slot.startISO,
      endISO: slot.endISO,
    }));
    slotModal.markConfirmed = false;

    const c = state.contacts.find(x => x.id === contactId);
    document.getElementById('slotModalTitle').textContent = c ? `Pick options for ${c.name}` : 'Pick options';
    updateWindowLabels();
    const timeStep = document.getElementById('timeStep');
    if (slotModal.selected.length) {
      const firstDay = toStartOfDay(new Date(slotModal.selected[0].startISO));
      slotModal.chosenDay = firstDay;
      timeStep.style.display = 'block';
      document.getElementById('pickedDayLabel').textContent = `Chosen: ${firstDay.toLocaleDateString(undefined, { weekday:'long', year:'numeric', month:'short', day:'2-digit' })}`;
    } else {
      timeStep.style.display = 'none';
    }
    document.getElementById('slotModalConfirmToggle').checked = false;

    renderDayPicker();
    if (slotModal.chosenDay) {
      renderTimePicker();
    }
    renderSelectedChips();

    document.getElementById('slotModalOverlay').style.display = 'flex';
  }

  function closeSlotModal() {
    slotModal.open = false;
    document.getElementById('slotModalOverlay').style.display = 'none';
  }

  function onModalOverlayClick(e) {
    if (e.target.id === 'slotModalOverlay') closeSlotModal();
  }

  function clearSelections() {
    slotModal.selected = [];
    slotModal.markConfirmed = false;
    document.getElementById('slotModalConfirmToggle').checked = false;
    renderSelectedChips();
    // also remove selected class on buttons
    document.querySelectorAll('.slotBtn.selected').forEach(b => b.classList.remove('selected'));
  }

  function renderDayPicker() {
    const container = document.getElementById('dayPicker');
    container.innerHTML = '';

    const weeks = getWeekSegments().map(week => week.filter(isWeekday));
    weeks.forEach((weekDays, index) => {
      if (!weekDays.length) return;
      if (index > 0) {
        container.appendChild(document.createElement('div')).style.height = '10px';
      }
      container.appendChild(makeWeekBlock(index + 1, weekDays, startOfWeekMonday(weekDays[0])));
    });
  }

  function makeWeekBlock(weekNumber, days, weekStart) {
    const wrap = document.createElement('div');
    const title = document.createElement('div');
    title.className = 'row';
    title.style.justifyContent = 'space-between';
    const startLabel = weekStart ? weekStart.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: '2-digit' }) : '';
    title.innerHTML = `<div class="weekLabel"><span class="weekPill">Week ${weekNumber}</span><span class="hint">Starts ${startLabel}</span></div>`;
    wrap.appendChild(title);

    const grid = document.createElement('div');
    grid.className = 'gridDays';
    grid.style.marginTop = '10px';

    days.forEach(d => {
      const btn = document.createElement('button');
      btn.className = 'slotBtn';
      btn.textContent = fmtDay(d);
      btn.onclick = () => chooseDay(d);
      grid.appendChild(btn);
    });

    wrap.appendChild(grid);
    return wrap;
  }

  function chooseDay(day) {
    slotModal.chosenDay = toStartOfDay(day);
    document.getElementById('timeStep').style.display = 'block';
    document.getElementById('pickedDayLabel').textContent = `Chosen: ${day.toLocaleDateString(undefined, { weekday:'long', year:'numeric', month:'short', day:'2-digit' })}`;
    renderTimePicker();
  }

  function renderTimePicker() {
    const container = document.getElementById('timePicker');
    container.innerHTML = '';

    const grid = document.createElement('div');
    grid.className = 'gridTimes';

    const blocked = getActiveRanges();

    const day = slotModal.chosenDay;
    const { startMinutes, endMinutes } = getWindowConfig();
    for (let minutes = startMinutes; minutes < endMinutes; minutes += SLOT_MINUTES) {
      const start = new Date(day);
      start.setHours(Math.floor(minutes / 60), minutes % 60, 0, 0);
      const end = new Date(start.getTime() + SLOT_MINUTES * 60000);
      const endMinutesValue = end.getHours() * 60 + end.getMinutes();
      if (endMinutesValue > endMinutes) continue;

      const hasConflict = blocked.some(r => overlaps(start, end, r.start, r.end));

      const btn = document.createElement('button');
      btn.className = 'slotBtn';
      btn.textContent = `${fmtTime(start)}`;
      btn.disabled = false; // we allow selecting even if conflict? Better: disable
      if (hasConflict) {
        btn.disabled = true;
        btn.title = 'Conflicts with an existing appointment option';
      }

      const key = start.toISOString();
      const isSelected = slotModal.selected.some(x => x.startISO === key);
      if (isSelected) btn.classList.add('selected');

      btn.onclick = () => toggleSlot({ startISO: start.toISOString(), endISO: end.toISOString() }, btn);
      grid.appendChild(btn);
    }

    container.appendChild(grid);

    // Small note
    const note = document.createElement('div');
    note.className = 'hint';
    note.style.marginTop = '10px';
    note.textContent = 'Greyed out slots are already blocked by an existing appointment option.';
    container.appendChild(note);
  }

  function toggleSlot(slot, btnEl) {
    const idx = slotModal.selected.findIndex(x => x.startISO === slot.startISO);
    if (idx >= 0) {
      slotModal.selected.splice(idx, 1);
      btnEl.classList.remove('selected');
      renderSelectedChips();
      return;
    }

    slotModal.selected.push(slot);
    btnEl.classList.add('selected');
    renderSelectedChips();
  }

  function renderSelectedChips() {
    const container = document.getElementById('selectedChips');
    container.innerHTML = '';

    if (slotModal.selected.length === 0) {
      const hint = document.createElement('div');
      hint.className = 'hint';
      hint.textContent = 'No times selected yet.';
      container.appendChild(hint);
    } else {
      slotModal.selected
        .slice()
        .sort((a,b) => new Date(a.startISO) - new Date(b.startISO))
        .forEach(s => {
          const chip = document.createElement('div');
          chip.className = 'chip';
          const ds = new Date(s.startISO);
          chip.innerHTML = `<span style="font-weight:700;">${fmtDay(ds)} · ${fmtTime(ds)}</span>`;
          const xBtn = document.createElement('button');
          xBtn.className = 'small';
          xBtn.textContent = 'Remove';
          xBtn.onclick = () => {
            slotModal.selected = slotModal.selected.filter(x => x.startISO !== s.startISO);
            renderTimePicker();
            renderSelectedChips();
          };
          chip.appendChild(xBtn);
          container.appendChild(chip);
        });
    }

    document.getElementById('saveSelectionsBtn').textContent = `Add options (${slotModal.selected.length})`;
    document.getElementById('saveSelectionsBtn').disabled = slotModal.selected.length === 0;
    updateSlotModalSuggested();
  }

  function getSlotModalSuggestedOptions() {
    const c = state.contacts.find(x => x.id === slotModal.contactId);
    if (!c) return [];
    const merged = new Map();
    (c.options || []).forEach(o => merged.set(o.startISO, o));
    slotModal.selected.forEach(s => {
      if (!merged.has(s.startISO)) merged.set(s.startISO, s);
    });
    return Array.from(merged.values());
  }

  function updateSlotModalSuggested() {
    const container = document.getElementById('slotModalSuggested');
    if (!container) return;
    const options = getSlotModalSuggestedOptions();
    if (options.length < 3) {
      container.style.display = 'none';
      container.innerHTML = '';
      return;
    }
    const { english, german } = buildAvailabilityMessages(options);
    container.style.display = 'block';
    container.innerHTML = `
      <div style="font-weight:800;">Suggested message (3 options selected)</div>
      <div class="hint" style="margin-top:6px;"><b>EN:</b> ${escapeHtml(english)}</div>
      <div class="hint" style="margin-top:6px;"><b>DE:</b> ${escapeHtml(german)}</div>
    `;
  }

  function saveSelections() {
    const c = state.contacts.find(x => x.id === slotModal.contactId);
    if (!c) return;

    slotModal.markConfirmed = document.getElementById('slotModalConfirmToggle').checked;

    // Avoid duplicates by start time
    const existingStarts = new Set(c.options.map(o => o.startISO));

    slotModal.selected
      .slice()
      .sort((a,b) => new Date(a.startISO) - new Date(b.startISO))
      .forEach(slot => {
        if (existingStarts.has(slot.startISO)) {
          if (slotModal.markConfirmed) {
            const existingOption = c.options.find(o => o.startISO === slot.startISO);
            if (existingOption) {
              confirmOption(c.id, existingOption.id, { silent: true });
            }
          }
          return;
        }
        const newOption = {
          id: crypto.randomUUID(),
          startISO: slot.startISO,
          endISO: slot.endISO,
          status: slotModal.markConfirmed ? 'confirmed' : 'proposed'
        };
        c.options.push(newOption);
        if (slotModal.markConfirmed) {
          confirmOption(c.id, newOption.id, { silent: true });
        }
      });

    save();
    closeSlotModal();
    render();
  }

  // --- Availability → Assign slot ---
  function openAssignModal(slot) {
    if (!state.contacts.length) {
      alert('Add at least one contact first.');
      return;
    }
    assignModal.open = true;
    assignModal.slot = slot;

    const ds = new Date(slot.startISO);
    document.getElementById('assignSlotLabel').textContent = `${ds.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'2-digit' })} · ${fmtTime(ds)}`;
    document.getElementById('assignConfirmToggle').checked = false;

    const select = document.getElementById('assignContactSelect');
    select.innerHTML = '';
    [...state.contacts].sort((a,b) => a.name.localeCompare(b.name)).forEach(c => {
      const opt = document.createElement('option');
      opt.value = c.id;
      opt.textContent = c.name;
      select.appendChild(opt);
    });

    document.getElementById('assignModalOverlay').style.display = 'flex';
  }

  function closeAssignModal() {
    assignModal.open = false;
    document.getElementById('assignModalOverlay').style.display = 'none';
  }

  function onAssignOverlayClick(e) {
    if (e.target.id === 'assignModalOverlay') closeAssignModal();
  }

  function confirmAssignSlot() {
    const cid = document.getElementById('assignContactSelect').value;
    const c = state.contacts.find(x => x.id === cid);
    if (!c) return;

    const markConfirmed = document.getElementById('assignConfirmToggle').checked;

    // Avoid duplicates
    const existingOption = c.options.find(o => o.startISO === assignModal.slot.startISO);
    if (!existingOption) {
      const newOption = {
        id: crypto.randomUUID(),
        startISO: assignModal.slot.startISO,
        endISO: assignModal.slot.endISO,
        status: markConfirmed ? 'confirmed' : 'proposed'
      };
      c.options.push(newOption);
      if (markConfirmed) {
        confirmOption(c.id, newOption.id, { silent: true });
      }
      save();
    } else if (markConfirmed) {
      confirmOption(c.id, existingOption.id, { silent: true });
      save();
    }

    closeAssignModal();
    render();
  }

  // --- Rendering ---
  function render() {
    const app = document.getElementById('app');
    app.innerHTML = '';

    const contacts = [...state.contacts].sort((a,b) => a.name.localeCompare(b.name));

    if (contacts.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'card';
      empty.innerHTML = `<b>Add a contact to start.</b><div class="hint" style="margin-top:6px;">After you add a contact, a picker pops up so you can choose weekday time options without typing.</div>`;
      app.appendChild(empty);
      return;
    }

    if (view === 'calendar') renderCalendar(app, contacts);
    if (view === 'availability') renderAvailability(app, contacts);
    if (view === 'confirmed') renderConfirmed(app, contacts);

    app.appendChild(renderContactsCard(contacts));
  }

  function renderCalendar(root, contacts) {
    const card = document.createElement('div');
    card.className = 'card scroll-x';

    const table = document.createElement('table');

    // header
    const head = document.createElement('tr');
    head.innerHTML = '<th class="dayCell">Day</th>' + contacts.map(c => {
      const email = c.email ? `<div class="hint">${escapeHtml(c.email)}</div>` : '';
      return `<th>
        <div class="row" style="justify-content: space-between; align-items:flex-start; gap:10px;">
          <div>
            <div style="font-weight:800;">${escapeHtml(c.name)}</div>
            ${email}
          </div>
          <div class="row">
            <button class="small" onclick="openSlotModal('${c.id}')">+ options</button>
            <button class="small danger" onclick="deleteContact('${c.id}')" title="Delete contact">Delete</button>
          </div>
        </div>
        <div class="hint" style="margin-top:6px;">Use “+ options” to add any number of slots.</div>
      </th>`;
    }).join('');
    table.appendChild(head);

    const days = getPlannerDays();

    for (let i = 0; i < days.length; i++) {
      const day = days[i];
      const tr = document.createElement('tr');
      if (i !== 0 && day.getDay() === 1) tr.classList.add('weekBreak');

      const weekNum = getWeekIndex(day);
      const weekPill = (i === 0 || day.getDay() === 1)
        ? `<span class="weekPill">Week ${weekNum}</span>`
        : '';

      tr.innerHTML = `<td class="dayCell"><div class="weekLabel">${weekPill}<span>${day.toLocaleDateString(undefined, { weekday:'short', year:'numeric', month:'short', day:'2-digit' })}</span></div></td>`;

      contacts.forEach(c => {
        const td = document.createElement('td');

        const opts = (c.options || [])
          .filter(o => toStartOfDay(new Date(o.startISO)).getTime() === toStartOfDay(day).getTime())
          .sort((a,b) => new Date(a.startISO) - new Date(b.startISO));

        if (opts.length === 0) {
          td.innerHTML = '<span class="hint">—</span>';
        } else {
          const activeRanges = getActiveRanges();

          opts.forEach(o => {
            const s = new Date(o.startISO);
            const e = new Date(o.endISO);
            const timeLabel = `${fmtTime(s)}–${fmtTime(e)}`;

            const conflicting = activeRanges.some(r => r.optionId !== o.id && overlaps(s, e, r.start, r.end));

            const div = document.createElement('div');
            div.className = 'option';
            div.innerHTML = `
              <div style="display:flex; justify-content:space-between; gap:10px; align-items:flex-start;">
                <div>
                  <div style="font-weight:800;">${timeLabel}
                    <span class="status ${o.status}">${o.status}</span>
                  </div>
                  ${conflicting ? `<div class="conflict">Conflicts with another appointment option</div>` : ''}
                </div>
              </div>
            `;

            const actions = document.createElement('div');
            actions.className = 'optionActions';

            if (o.status !== 'confirmed') {
              const btnC = document.createElement('button');
              btnC.className = 'confirm small';
              btnC.textContent = 'Confirm';
              btnC.title = 'Mark this as confirmed (other proposed options for this contact are archived)';
              btnC.onclick = () => confirmOption(c.id, o.id);
              actions.appendChild(btnC);
            } else {
              const btnU = document.createElement('button');
              btnU.className = 'small';
              btnU.textContent = 'Unconfirm';
              btnU.onclick = () => { o.status = 'proposed'; save(); render(); };
              actions.appendChild(btnU);
            }

            const btnR = document.createElement('button');
            btnR.className = 'small';
            btnR.textContent = 'Archive';
            btnR.onclick = () => archiveOption(c.id, o.id);
            actions.appendChild(btnR);

            div.appendChild(actions);
            td.appendChild(div);
          });
        }

        tr.appendChild(td);
      });

      table.appendChild(tr);
    }

    card.appendChild(table);

    const note = document.createElement('div');
    note.className = 'hint';
    note.style.marginTop = '10px';
    note.textContent = 'Week separation follows Mondays and is shown by a thicker border and “Week” badges.';
    card.appendChild(note);

    root.appendChild(card);
  }

  function renderAvailability(root, contacts) {
    const card = document.createElement('div');
    card.className = 'card';

    const title = document.createElement('div');
    const { startLabel, endLabel } = getWindowConfig();
    title.innerHTML = `<b>Available slots (Mon–Fri · ${startLabel}–${endLabel} · next 3 weeks)</b><div class="hint" style="margin-top:6px;">These are standard slots that don’t overlap any existing appointment option (proposed or confirmed). Click a slot to add it as a proposed option for a contact.</div>`;
    card.appendChild(title);

    const blocked = getActiveRanges();
    const all = getStandardSlots();

    // Free if it doesn't overlap any proposed or confirmed appointment
    const free = all.filter(s => {
      const st = new Date(s.startISO);
      const en = new Date(s.endISO);
      return !blocked.some(r => overlaps(st, en, r.start, r.end));
    });

    // Group by day
    const groups = new Map();
    free.forEach(s => {
      const d = toStartOfDay(new Date(s.startISO)).toISOString();
      if (!groups.has(d)) groups.set(d, []);
      groups.get(d).push(s);
    });

    const days = Array.from(groups.keys()).sort().map(k => ({ key: k, day: new Date(k), slots: groups.get(k) }));

    const wrap = document.createElement('div');
    wrap.style.marginTop = '12px';

    if (days.length === 0) {
      const none = document.createElement('div');
      none.className = 'subtle';
      none.innerHTML = '<b>No free slots found.</b><div class="hint" style="margin-top:6px;">Try removing or unconfirming some appointments.</div>';
      wrap.appendChild(none);
    } else {
      days.forEach((g, idx) => {
        const block = document.createElement('div');
        block.className = 'subtle';
        block.style.marginBottom = '10px';

        const weekNum = getWeekIndex(g.day);
        const label = document.createElement('div');
        label.className = 'row';
        label.style.justifyContent = 'space-between';
        label.innerHTML = `<div class="weekLabel"><span class="weekPill">Week ${weekNum}</span><span style="font-weight:800;">${g.day.toLocaleDateString(undefined, { weekday:'long', month:'short', day:'2-digit' })}</span></div>`;
        block.appendChild(label);

        const grid = document.createElement('div');
        grid.className = 'gridTimes';
        grid.style.marginTop = '10px';

        g.slots.sort((a,b) => new Date(a.startISO) - new Date(b.startISO)).forEach(s => {
          const st = new Date(s.startISO);
          const btn = document.createElement('button');
          btn.className = 'slotBtn';
          btn.textContent = fmtTime(st);
          btn.onclick = () => openAssignModal(s);
          grid.appendChild(btn);
        });

        block.appendChild(grid);
        wrap.appendChild(block);
      });
    }

    card.appendChild(wrap);
    root.appendChild(card);
  }

  function renderConfirmed(root, contacts) {
    const card = document.createElement('div');
    card.className = 'card';

    const title = document.createElement('div');
    title.innerHTML = `<b>Confirmed appointments</b><div class="hint" style="margin-top:6px;">This is what is booked across all contacts.</div>`;
    card.appendChild(title);

    const list = [];
    contacts.forEach(c => c.options.filter(o => o.status === 'confirmed').forEach(o => list.push({ c, o })));
    list.sort((a,b) => new Date(a.o.startISO) - new Date(b.o.startISO));

    const wrap = document.createElement('div');
    wrap.style.marginTop = '12px';

    if (list.length === 0) {
      const none = document.createElement('div');
      none.className = 'subtle';
      none.textContent = 'No confirmed appointments yet.';
      wrap.appendChild(none);
    } else {
      list.forEach(item => {
        const div = document.createElement('div');
        div.className = 'option';
        const s = new Date(item.o.startISO);
        const e = new Date(item.o.endISO);
        div.innerHTML = `
          <div style="font-weight:900;">${escapeHtml(item.c.name)}</div>
          <div class="hint" style="margin-top:4px;">${s.toLocaleDateString(undefined, { weekday:'short', year:'numeric', month:'short', day:'2-digit' })} · ${fmtTime(s)}–${fmtTime(e)}</div>
        `;
        const actions = document.createElement('div');
        actions.className = 'optionActions';

        const unconfirm = document.createElement('button');
        unconfirm.className = 'small';
        unconfirm.textContent = 'Unconfirm';
        unconfirm.onclick = () => { item.o.status = 'proposed'; save(); render(); };
        actions.appendChild(unconfirm);

        const remove = document.createElement('button');
        remove.className = 'small';
        remove.textContent = 'Archive';
        remove.onclick = () => archiveOption(item.c.id, item.o.id);
        actions.appendChild(remove);

        div.appendChild(actions);
        wrap.appendChild(div);
      });
    }

    card.appendChild(wrap);
    root.appendChild(card);
  }

  function renderContactsCard(contacts) {
    const card = document.createElement('div');
    card.className = 'card';

    const title = document.createElement('div');
    title.innerHTML = `<b>Contacts</b><div class="hint" style="margin-top:6px;">Quick overview and cleanup.</div>`;
    card.appendChild(title);

    const list = document.createElement('div');
    list.style.marginTop = '10px';

    contacts.forEach(c => {
      const box = document.createElement('div');
      box.className = 'subtle';
      box.style.marginBottom = '10px';

      const counts = {
        total: (c.options || []).length,
        proposed: (c.options || []).filter(o => o.status === 'proposed').length,
        confirmed: (c.options || []).filter(o => o.status === 'confirmed').length,
        archived: (c.archivedOptions || []).length,
      };

      box.innerHTML = `
        <div class="row" style="justify-content:space-between; gap:10px;">
          <div>
            <div style="font-weight:900;">${escapeHtml(c.name)}</div>
            <div class="hint">${c.email ? escapeHtml(c.email) : '—'}</div>
          </div>
          <div class="row">
            <button class="small" onclick="openSlotModal('${c.id}')">Pick options</button>
            <button class="small danger" onclick="deleteContact('${c.id}')">Delete</button>
          </div>
        </div>
        <div class="hint" style="margin-top:8px;">Total: ${counts.total} · Proposed: ${counts.proposed} · Confirmed: ${counts.confirmed} · Archived: ${counts.archived}</div>
      `;

      list.appendChild(box);

      if ((c.archivedOptions || []).length) {
        const archiveWrap = document.createElement('div');
        archiveWrap.style.marginTop = '10px';

        const title = document.createElement('div');
        title.className = 'hint';
        title.textContent = 'Archived options (auto-archived after confirmation).';
        archiveWrap.appendChild(title);

        const archivedList = document.createElement('div');
        archivedList.style.marginTop = '8px';

        c.archivedOptions
          .slice()
          .sort((a,b) => new Date(a.startISO) - new Date(b.startISO))
          .forEach(o => {
            const s = new Date(o.startISO);
            const e = new Date(o.endISO);
            const row = document.createElement('div');
            row.className = 'option';
            row.innerHTML = `
              <div style="font-weight:800;">${fmtDay(s)} · ${fmtTime(s)}–${fmtTime(e)}
                <span class="status removed">archived</span>
              </div>
            `;

            const actions = document.createElement('div');
            actions.className = 'optionActions';

            const restore = document.createElement('button');
            restore.className = 'small';
            restore.textContent = 'Restore';
            restore.onclick = () => restoreArchivedOption(c.id, o.id);
            actions.appendChild(restore);

            const discard = document.createElement('button');
            discard.className = 'small danger';
            discard.textContent = 'Delete';
            discard.onclick = () => deleteArchivedOption(c.id, o.id);
            actions.appendChild(discard);

            row.appendChild(actions);
            archivedList.appendChild(row);
          });

        archiveWrap.appendChild(archivedList);
        box.appendChild(archiveWrap);
      }
    });

    card.appendChild(list);
    return card;
  }

  function escapeHtml(str) {
    return String(str)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  syncWindowInputs();
  updateWindowLabels();
  render();
</script>
</body>
</html>
